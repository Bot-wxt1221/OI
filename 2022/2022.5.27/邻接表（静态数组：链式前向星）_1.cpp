//ver数组存储的是每条边的终点 
//head与next数组存的是ver数组的下标，相当于指针，0表示指向空 

// 邻接表：加入有向边(x, y)，权值为z
void add(int x, int y, int z) {
	ver[++tot] = y, edge[tot] = z; // 真实数据
	next[tot] = head[x], head[x] = tot; // 在表头x处插入
}

// 邻接表：访问从x出发的所有边
for (int i = head[x]; i; i = next[i]) {
	int y = ver[i], z = edge[i];
	// 一条有向边(x, y)，权值为z
}

//------------------------------------------------------------------
/*
   对于无向图，可以把每条无向边看作两条有向边插入即可。
   小技巧：利用“成对变换”的位运算性质，我们可以在程序开始时，初始化
   tot = 1。这样每条无向边看成两条有向边会成对存储在 ver 和 edge 数组
   的下标 “2和 3”“ 4和 5” “6和 7”......的位置上。通过对下标进行
   异或 1 的运算，就可以直接定位到与当前反向的边。
   换句话说，如果 ver[i] 是第 i 条边的终点，那么 ver[i or 1] 就是第 i
   条边的起点。
*/
