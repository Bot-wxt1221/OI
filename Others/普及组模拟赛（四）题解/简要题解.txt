bread：
对于k>=n的情况只要两次就能做好了，不要问我是为什么。
对于k<n的情况
 一、如果n*2 mod k=0(正好分配完)，那答案就是（n*2 div k）
 二、如果n*2 mod k≠0，那答案就是（n*2 div k）+1
//例：n=4，k=3；①1、2、3烤一面；②1、2、4烤一面③3、4烤一面


phrase：
暴力模拟


mountain:
经典题：打导弹（最长上升子序列）
30暴力
50要求O（n^2）
100要求O（nlogn）
（一篇讲nlogn的博文，还算详细
http://blog.csdn.net/shuangde800/article/details/7474903）


prize：
赤裸裸的模拟
ps：看题仔细点


gou：
sol 1 :
设f(n)为一个象限和一个坐标轴上半径=n的圆上的整点数，也就是半径为n的圆上的整点数/4
f(n)是个积性函数
当 p % 4 = 1 时，f(p ^ a) = 2 * a + 1, 否则 f(p ^ a) = 1
然后这题的答案就是 \sum (f(i) - 1) / 2


sol 2 :
花2个小时不到的时间把 n = 1 ~ 1e6 的答案全部打出来
但是会有代码长度的限制
所以可以
1.直接暴力 每500个左右打一个答案 只要暴力处理500个r
2.用bzoj1041的传统做法，可以处理多一点
